技术设计文档：memtool 记忆管理工具（SQLite MVP）

1. 背景与目标

在 agent 驱动开发流程里（Claude Code / Codex），记忆需要满足三件事
	•	读：快速定位并读取“正确的那条记忆”
	•	写：更新或追加记忆时，能追踪版本与来源
	•	查：支持全文检索与按任务维度过滤

本工具 memtool 的目标是提供一个本地可携带、零运维、默认 JSON 输出的记忆存储与检索能力，作为后续 Control Plane 的 Memory Store 基础实现。

2. 范围与非目标

范围
	•	本地 SQLite 存储 A/B/C 三层记忆（project / feature / run）
	•	支持 put / get / list / search / delete / export / import
	•	默认 JSON 输出，方便 agent 解析
	•	FTS5 可用时启用全文检索，自动降级 LIKE
	•	中文检索使用 jieba 分词（过滤长度 < 2 的 token）

非目标
	•	多租户隔离、权限审批、加密、远程服务化
	•	高并发写入优化到极致（MVP 以稳定可用为主）
	•	复杂结构化检索（例如 embedding 相似度检索）

3. 总体架构

形态：单机 CLI 工具 + 单文件 SQLite DB

组件
	•	CLI 层：参数解析、输入读取（stdin / file / inline）、输出序列化（JSON / text）
	•	Storage 层：SQLite 表 memory_items，WAL 模式提升并发读写体验
	•	Search 层：优先使用 FTS5 虚表 memory_fts，不可用时退化为 LIKE
	•	Sync 层：触发器同步 memory_items.content_search 到 memory_fts（content_search 含 jieba 分词）

4. 核心数据模型

4.1 表：memory_items

每条记忆为一行，字段如下
	•	id：主键，UUID4 hex
	•	type：枚举 project | feature | run
	•	task_id：可空，建议对应一个需求或 bugfix
	•	step_id：可空，建议对应一个执行步骤
	•	key：业务语义键（建议固定集合）
	•	content：正文，文本或 JSON 字符串都可
	•	content_search：用于检索的内容（content + jieba 分词结果）
	•	tags_json：JSON array string，标签集合
	•	source：来源，如 PRD / manual / log / stacktrace
	•	weight：权重，给后续 Context Router 用
	•	version：版本号，更新同 id 时自动 +1
	•	created_at / updated_at：UTC ISO 时间

索引
	•	(type, key)
	•	(task_id, step_id)
	•	(updated_at)

4.2 全文检索：memory_fts（可选）
	•	虚表字段：id, content_search
	•	tokenize：unicode61
	•	触发器：insert / delete / update(content, content_search) 自动同步
	•	中文分词：content_search = content + jieba 分词（过滤长度 < 2 的 token）

兼容性策略
	•	初始化时尝试创建 FTS5
	•	若 SQLite 不支持 FTS5，search 自动降级 LIKE

4.3 Content 格式建议

为了提升 agent 的理解效率和全文检索效果，推荐使用以下格式：

**推荐格式：Markdown**

适用场景：大部分记忆（描述、规则、经验、代码片段）

优势：
	•	LLM 直接理解，无需解析
	•	全文检索效果好
	•	可混合文本、代码、列表等多种内容

8. Phase 2：排序 / 推荐 / 生命周期

8.1 混合排序（confidence + recency）
	•	confidence_score：high=1.0, medium=0.6, low=0.3
	•	recency_score：基于“遗忘曲线”指数衰减
	•	混合评分：score = 0.6 * confidence_score + 0.4 * recency_score
	•	CLI 支持 --sort-by {updated,confidence,recency,mixed}

8.2 推荐引擎（轻量级）
	•	候选召回：task_id / tag / key_prefix 过滤，按 updated_at 取近期数据
	•	相关性：关键词重合（Jaccard）
	•	最终评分：relevance + confidence + recency + weight
	•	返回理由：context_match / high_confidence / recent / high_weight

8.3 生命周期管理（遗忘曲线）
	•	衰减公式：decay = exp(-ln2 * age_days / half_life_days)
	•	半衰期：run=14d, feature=180d, project=365d
	•	is_stale：decay <= 0.2
	•	cleanup：默认 dry-run，显式 apply 才删除
	•	人类可读性强

示例：
```
## API Contract

POST /api/v1/login

### Request
- username: string
- password: string

### Business Rules
- 密码至少 8 位
- 失败重试限制：15 分钟内最多 5 次
```

**可选格式：JSON**

适用场景：配置信息、结构化规则集（需要程序化处理）
注意：纯 JSON 不利于全文检索

**混合格式：Markdown + 代码块**（最佳实践）

在 Markdown 中嵌入 JSON/YAML/代码块，兼顾可读性和结构化：
```
## Database Configuration

```json
{
  "host": "localhost",
  "port": 5432
}
```

## Notes
- pool_size 设置为 10 是因为预期并发量不高
```

**格式识别**：
	•	memtool 不强制格式，agent 自行判断
	•	建议：如果 content 是合法 JSON 对象/数组，则视为 JSON；否则视为文本

5. 记忆分层约定（推荐）

为了让 agent 调用更稳定，建议约定 key 集合

Project（A）
	•	glossary 领域词汇
	•	invariants 不变量
	•	boundaries 系统边界

Feature（B）
	•	goal_scope 目标与范围
	•	contract 接口契约
	•	business_rules 业务规则
	•	scenarios 场景库
	•	risk_notes 风险点

Run（C）
	•	reproduction 复现步骤
	•	stacktrace 堆栈
	•	logs_excerpt 日志片段
	•	diff_summary 变更摘要
	•	context_requests 增量上下文请求记录

6. CLI 设计

6.1 全局参数
	•	--db：SQLite 路径，默认读取环境变量 MEMTOOL_DB，否则 ./memtool.db
	•	--format：默认 json，可选 text（便于人读）

6.2 命令与行为
	•	init：初始化 schema，开启 WAL，尝试启用 FTS5
	•	put：写入或更新
		•	content 来源：--content / --file / stdin
		•	更新策略：
			•	方式1：按 id 更新（--id <id>）
				•	若 id 存在：更新整条记录并 version+1
				•	若 id 不存在：返回错误
			•	方式2：按逻辑键 upsert（不提供 --id，但提供 type + key + task_id? + step_id?）
				•	若逻辑键匹配到已有记录：更新该记录并 version+1
				•	若逻辑键未匹配：创建新记录
			•	方式3：创建新记录（不提供 --id，也不提供完整逻辑键）
				•	生成新 id，version=1
	•	get：读取
	•	--id 精确读取
	•	或按 (type, key, task_id?, step_id?) 取 updated_at 最新一条
	•	list：列表过滤
	•	支持 type / task_id / step_id / key / tag / limit
	•	search：全文检索
	•	优先 FTS5 MATCH
	•	不支持则 LIKE
	•	中文内容会先做 jieba 分词以提升检索命中率
	•	支持附加过滤 type / task_id / step_id / key / limit
	•	delete：按 id 删除
	•	export：导出 JSONL（每行一条完整对象）
	•	import：导入 JSONL（按 id upsert）

7. 输出协议（对 agent 友好）

默认输出 JSON，字段固定，方便 Claude Code / Codex 解析。

单条 item 返回结构
	•	id, type, task_id, step_id, key, content, tags, source, weight, version, created_at, updated_at

search 返回结构
	•	ok
	•	fts5：是否走 FTS5
	•	items：匹配项数组（同 item 结构）

错误返回结构（统一）
	•	ok: false
	•	error: <error_code>
	•	message: <human_readable_message>
	•	hint / query / id（可选辅助字段）

**错误码定义**：

| 退出码 | error_code | 说明 | 示例场景 |
|-------|-----------|------|---------|
| 0 | - | 成功 | - |
| 1 | GENERAL_ERROR | 通用错误 | 未预期的异常 |
| 2 | PARAM_ERROR | 参数错误 | 缺少必需参数、参数格式错误 |
| 3 | NOT_FOUND | 数据不存在 | get/delete 找不到指定 id |
| 4 | DB_ERROR | 数据库错误 | 锁定超时、文件损坏、磁盘满 |
| 5 | FTS_UNAVAILABLE | FTS5 不可用 | 降级为 LIKE（仅警告，不影响功能） |

**错误信息示例**：

```json
// 参数缺失
{
  "ok": false,
  "error": "PARAM_ERROR",
  "message": "Required parameter --type is missing",
  "hint": "Use --type project|feature|run"
}

// 数据不存在
{
  "ok": false,
  "error": "NOT_FOUND",
  "message": "No memory item found with id: abc123",
  "id": "abc123"
}

// 数据库锁定
{
  "ok": false,
  "error": "DB_ERROR",
  "message": "Database is locked (timeout after 5000ms)",
  "hint": "Another process may be writing. Retry after a short delay."
}
```

**Agent 使用建议**：
	•	PARAM_ERROR：检查参数，不要重试
	•	NOT_FOUND：确认 id 是否正确，或使用 search 查找
	•	DB_ERROR：等待 1-2 秒后重试（最多 3 次）
	•	FTS_UNAVAILABLE：不影响功能，可忽略

8. 并发与一致性

8.1 并发模型
	•	SQLite 启用 WAL：读写并发更友好（多读一写）
	•	写入粒度：单条 item 级别更新，使用事务提交
	•	触发器同步 FTS：保证 search 与 content 基本一致（同步触发器）

8.2 并发写入行为

**场景1：多个 agent 同时写入不同记忆**
	•	行为：并发执行，互不影响
	•	示例：Agent A 写入 task_id=T123，Agent B 写入 task_id=T124

**场景2：多个 agent 同时更新同一条记忆（相同 id）**
	•	行为：SQLite 串行化，后者覆盖前者
	•	version 基于最后一次成功写入递增
	•	示例：
		•	Agent A: put --id abc123 --content "v1" (version: 2 → 3)
		•	Agent B: put --id abc123 --content "v2" (version: 3 → 4)
		•	最终结果：content="v2", version=4

**场景3：多个 agent 同时 upsert 同一逻辑键**
	•	行为：SQLite 串行化，后者覆盖前者
	•	可能导致"丢失更新"问题
	•	建议：不同 agent 使用不同的 step_id，避免冲突

8.3 锁超时配置

```python
# 代码实现中应包含
conn.execute("PRAGMA busy_timeout = 5000")  # 5 秒超时
```

	•	超时时间：5000ms（5 秒）
	•	超时后：返回 DB_ERROR（退出码 4）
	•	Agent 处理：等待 1-2 秒后重试（最多 3 次）

8.4 推荐的并发使用模式

**模式1：按 step_id 隔离**（推荐）
```bash
# Agent A
./memtool.py put --type run --task-id T123 --step-id S1 --key logs

# Agent B
./memtool.py put --type run --task-id T123 --step-id S2 --key logs
```
	•	不同 step_id，不会冲突

**模式2：按 key 隔离**
```bash
# Agent A 负责 stacktrace
./memtool.py put --type run --task-id T123 --key stacktrace

# Agent B 负责 diff_summary
./memtool.py put --type run --task-id T123 --key diff_summary
```
	•	不同 key，不会冲突

**反模式：多个 agent 更新同一逻辑位置**（避免）
```bash
# Agent A 和 Agent B 同时更新同一个 contract
# 可能导致一方的更新被覆盖
```

8.5 已知限制
	•	高并发写入下仍会串行化，这是 SQLite 的设计选择
	•	MVP 阶段可接受（预期并发量不高）
	•	如需更高并发，考虑后续演进为远程服务（第 13 节）

9. 安全与风险
	•	content 为纯文本存储，工具不执行 content 内容
	•	search 降级为 LIKE 时存在性能风险（大数据量）
	•	tags 用 LIKE 匹配 JSON 字符串，精确性有限（MVP 可接受）

建议的使用约束
	•	记忆里避免写入明文密钥
	•	run 层日志截断或脱敏后再存

10. 测试策略（MVP）

建议最少测试集
	•	init 后表与索引存在，FTS5 存在时触发器生效
	•	put 插入与更新（version 递增）
	•	get by id 与 get by query 返回最新一条
	•	list 过滤与 limit 正确
	•	search 在 FTS5 与 LIKE 两种模式下可用
	•	中文分词检索可用（短词命中）
	•	export/import 回放一致

11. 部署与交付
	•	单文件 Python 脚本 + SQLite db 文件
	•	适合放进仓库的 tools/ 目录，或作为 Control Plane 的 sidecar 工具
	•	通过环境变量 MEMTOOL_DB 管理默认路径，便于 CI 或 agent runner 接入

12. 与 Claude Code / Codex 的集成方式

推荐调用模式
	1.	search 定位候选
	2.	get --id 获取完整内容
	3.	修复或补充后 put 写回 run 层或 feature 层
	4.	需要迁移或备份时用 export/import

最佳实践
	•	feature 级记忆按 task_id 维度组织
	•	run 级记忆按 step_id 维度组织
	•	更新同一条“权威记忆”用固定 id（put update），保留版本轨迹

13. 后续演进建议

下一步最值得加的能力
	•	upsert-by-key：按 (type, task_id, step_id, key) 更新同一逻辑项，减少先查 id 的往返
	•	tags 的规范化表（提升精确过滤）
	•	结构化字段（例如 content_json）与 schema 校验
	•	支持远程模式（HTTP API），以便多机 worker 共享记忆
